// LIBRARIES //
#include <Sabertooth.h> //SABERTOOTH LIBRARY WHICH HOLDS THE ST.MOTOR COMMANDS
#include <SoftwareSerial.h> //USED FOR SETTING THE MOTOR CONTROLLER SERIAL PIN DIGITAL PIN 2  

// SABERTOOTH PINS //
#define SABERTOOTH_ADDRESS 128 	//ADDRESS OF SABERTOOTH SET WITH DIP SWITCHES
#define DRIVE_MOTOR 1 //DRIVE MOTOR ON CHANNEL 1 (M1A AND M1B) OF SABERTOOTH
#define SABERTOOTH_COM 11 //S1 PIN OF SABERTOOTH CONNECTED TO PIN D11 SET THROUGH SOFTWARE SERIAL

SoftwareSerial SWSerial(NOT_A_PIN, SABERTOOTH_COM); //RX ON NO PIN (UNUSED), TX2 ON DIGITAL PIN 11 (TO S1)
Sabertooth ST(SABERTOOTH_ADDRESS, SWSerial); //ADDRESS 128, AND USE SWSERIAL AS THE SERIAL PORT.

// ANALOG PINS //
int THROTTLE_PIN = 0; //THROTTLE PIN (POTENTIOMETER) CONNECTED TO A0.............................GREEN WIRE ON ARDUINO


// DIGITAL PINS //
int DIRECTION_PIN = 12;//RELAY SIGNAL (COIL) PIN
int KEY_SWITCH = 2; //CONNECTED TO ANALOG PIN A4   - ANYTHING ABOVE 1V IS KEY SWITCH ENGANGED....RED WIRE ON ARDUINO
int FORWARD_PIN = 4; //FORWARD PIN ON DASHBOARD SWITCH CONNECTED TO PIN D4.......................BLACK WIRE ON ARDUINO
int REVERSE_PIN = 6; //REVERSE PIN ON DASHBOARD SWITCH CONNECTED TO PIN D6.......................WHITE WIRE ON ARDUINO


// GLOBAL PARAMETERS //
float THROTTLE_CALIBRATE_AVERAGE; //USED TO CALIBRATE THE INITIAL POTENTIOMETER POSITION
long POPULATION = 50; //NUMER OF DATA POINTS USED TO AVERAGE OVER THE THROTTLE PEDAL (POTENTIOMETER) INPUT POSITION AND SMOOTH CONTINUOUS MOTION 
float POWER_SCALE = 0.25; //LIMITS THE POWER OF THE DRIVE MOTOR. CAN BE ANY VALUE FROM 0.01-1.0; WHERE 1.0 IS FULL POWER
float THROTTLE_CUTOFF = 0.00; //INITIAL PERCENTAGE OF THROTTLE INPUT WHICH WILL NOT ACTUATE THE DRIVE MOTOR. USED SO THROTTLE IS LESS SENSITIVE
float POWER_OLD = 0; //USED FOR SMOOTHING OUT THE POWER COMMANDS SENT TO THE MOTOR.
float POWER = 0; //USED FOR SMOOTHING OUT THE POWER COMMANDS SENT TO THE MOTOR. POWER CAN BE FROM 0-127 IN THE CASE OF THIS MOTOR


void setup()
{
  Serial.begin(57600); //SERIAL COMMUNICATION WITH LAPTOP OVER USB, MAINLY USED FOR TROUBLESHOOTING
  SWSerial.begin(9600); //SERIAL COMMUNICATION WITH SABERTOOTH, SET USING DIP SWITCHES................................................... RED WIRE FROM RELAY TO SABERTOOTH
  ST.autobaud(); //SABERTOOTH COMMUNICATION SET TO REFRESH, NOT NECESSARY
  
  float THROTTLE_CALIBRATE_SUM; //COLLECT SEVERAL THROTTLE POSITION VALUES ON STARTUP TO ZERO THROTTLE POSITION
  for(int i = 0; i <= POPULATION; i++)
  {
    analogRead(THROTTLE_PIN);
    THROTTLE_CALIBRATE_SUM += analogRead(THROTTLE_PIN);  
  }
  
  THROTTLE_CALIBRATE_AVERAGE = THROTTLE_CALIBRATE_SUM/POPULATION;
  
  pinMode(DIRECTION_PIN, OUTPUT); //CONNECTED TO DIRECTION RELAY TO CONTROL FWD OR REV MOTION OF MOTOR
  digitalWrite(DIRECTION_PIN, HIGH); //HIGH CORRESPONDS TO FORWARD MOTION
  pinMode(KEY_SWITCH, INPUT); //CONNECTED TO ORIGINAL KEY OF VEHICLE ANDED WITH MANUAL SWITCH ON DASHBOARD............................... GREEN WIRE FROM DASHBOARD TO ARDIUNO
  pinMode(FORWARD_PIN, INPUT); //CONNECTED TO NEW FWD/REV SWITCH FOR MANUAL CONTROL OVER MOTOR DIRECTION................................. BLUE WIRE FROM DASHBOARD FWD SWITCH TO ARDIUNO
  pinMode(REVERSE_PIN, INPUT); //CONNECTED TO NEW FWD/REV SWITCH FOR MANUAL CONTROL OVER MOTOR DIRECTION................................. BLU* WIRE FROM DASHBOARD REV TO ARDIUNO
  
  Serial.println(" "); //SERIAL PRINTS ARE ONLY USED WHEN CONNECTED TO LAPTOP FOR TROUBLESHOOTING
  Serial.print("KEY");
  SPACER();
  Serial.print("DIRECTION");
  SPACER();
  Serial.print("THROTTLE_CORRECTED");
  SPACER();
  Serial.print("POWER");
  SPACER();
  Serial.println(" ");
}

void loop()
{ 
  boolean KEY_POSITION = digitalRead(KEY_SWITCH); //1 IF KEY SWITCH AND MANUAL SWITCH ARE BOTH ENGAGED
  boolean FORWARD_POSITION = digitalRead(FORWARD_PIN); //1 IF FORWARD, 0 IF REVERSE
  boolean REVERSE_POSITION = digitalRead(REVERSE_PIN); //0 IF FORWARD, 1 IF REVERSE
  boolean DIRECTION_STATUS; //VALUE OF 1 IF FORWARD OR REVERSE IS SELECTED, VALUE OF 0 IF NEITHER ARE SELECTED
  
  while(KEY_POSITION == 0) //WHILE KEY OR MANUAL SWITCH IS DISENGAGED, DO NOT DRIVE MOTOR
  {
    SHUTDOWN(); //STANDARD PROCEDURE TO ENSURE MOTOR DOES NOT GET DRIVEN
    KEY_POSITION = digitalRead(KEY_SWITCH);
    delay(10);
  }
    
  if(KEY_POSITION == 1){
    Serial.print("ON");
    SPACER();
    DIRECTION_STATUS = RELAY_ACTUATOR(FORWARD_POSITION, REVERSE_POSITION); //BASED ON DASHBOARD SWITCH POSITION, TURN ON OR OFF RELAYS WHICH CONTROL DIRECTION
    if(DIRECTION_STATUS == 1){ 
      POWER = THROTTLE_MAP(THROTTLE_CALIBRATE_AVERAGE); //MAP THE THROTTLE POSITION TO SOME DESIRED POWER TO SEND TO MOTOR (INCLUDES SMOOTHING)
      if(POWER > 0.0 && POWER < 127) // REDUNDANT POWER CHECK TO ENSURE POWER IS WITHIN EXPECTED RANGE
      {
     ST.motor(DRIVE_MOTOR, POWER); //SEND POWER COMMAND TO SABERTOOTH FOR THE CORRECT MOTOR////////////////////////////////////////////////////////////////////////////////////////
      }
    }
  }
    
  POWER_OLD = POWER; //UPDATE POWER FOR SMOOTHING
  Serial.println(" ");
}


boolean RELAY_ACTUATOR(boolean FORWARD_POSITION, boolean REVERSE_POSITION){
  boolean DIRECTION_STATUS;
  
  Serial.print("DIRECTION:");

  if(FORWARD_POSITION == 1 && REVERSE_POSITION == 0){
      digitalWrite(DIRECTION_PIN, HIGH);
      DIRECTION_STATUS = 1;
      Serial.print("FORWARD");
      SPACER();
  }
  else if (FORWARD_POSITION == 0 && REVERSE_POSITION == 1){
      digitalWrite(DIRECTION_PIN, LOW);
      DIRECTION_STATUS = 1;
      Serial.print("REVERSE");
      SPACER();
  }
  else{
    digitalWrite(DIRECTION_PIN, HIGH); //DEFAULT TO FORWARD POSITION (REDUNDANT)
    DIRECTION_STATUS = 0;
    Serial.print("STOPPED");
    SPACER();
  }
  return DIRECTION_STATUS; //SETS TO 1 IF EITHER DIRECTION IS SELECTED
}


float mapfloat(float x, float in_min, float in_max, float out_min, float out_max) //USED FOR MAPPING TO A FLOAT VALUE
{
 return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}


float THROTTLE_MAP(float THROTTLE_CALIBRATE_AVERAGE){

  float THROTTLE_SUM; //SUM ANALOG THROTTLE POSITION OVER SEVERAL READINGS TO SMOOTH VALUE
  float THROTTLE_AVERAGE; //AVERAGE OF THROTTLE INPUTS OVER POPULATION NUMBER OF READINGS
  float THROTTLE_CORRECTED; //CORRECTED THROTTLE POSITION TO ACCOUNT FOR INITIAL ZERO OF THROTTLE ON STARTUP
  float SMOOTH_SCALE = 0.7; //PERCENT OF NEW POWER READING TO COMBINE WITH OLD POWER READING TO SMOOTH ACCELERATION OF MOTOR
  
  for(int i = 0; i < POPULATION; i++)
  {
    analogRead(THROTTLE_PIN); //MULTIPLE ANALOG READS ON SAME PIN TO ENSURE THE READING IS ACCURATE (EACH ANALOG READ COMMAND GETS THE READING CAPACITOR CLOSER TO THE ACTUAL VALUE)
    analogRead(THROTTLE_PIN);
    THROTTLE_SUM += analogRead(THROTTLE_PIN);  
  }
  THROTTLE_AVERAGE = THROTTLE_SUM/POPULATION;
  THROTTLE_CORRECTED = (THROTTLE_AVERAGE - THROTTLE_CALIBRATE_AVERAGE); //CORRECTS THE THROTTLE POSITION BY SUBTRACTING THE INITIAL POSITION READING (FLOATING ZERO CORRECTION)
  
  Serial.print(POPULATION); 
  SPACER();
  Serial.print(THROTTLE_CALIBRATE_AVERAGE); 
  SPACER();
  Serial.print(THROTTLE_AVERAGE); 
  SPACER();
  Serial.print(THROTTLE_CORRECTED); 
  SPACER();
  
  POWER = mapfloat(THROTTLE_CORRECTED, 0.0, 70.0, 0.0 ,127.0); //MAP POWER FROM THE PEDAL'S FULL RANGE TO THE MOTOR'S FULL RANGE
  POWER = (POWER)*(POWER_SCALE); //SCALE (LIMIT) THE POWER ACCORDINGLY
  if(POWER > THROTTLE_CUTOFF*127*POWER_SCALE){ //IF POWER VALUE IS BEYOND THE CUTOFF (DEFINED AT START OF CODE) THEN CONTINUE
    POWER=POWER;
  }
  else
  {
    POWER = 0; //IF THROTTLE IS BELOW THE CUTOFF THRESHHOLD THEN SET POWER TO ZERO TO FORCE NOT DRIVING MOTOR
  }
  POWER = POWER*SMOOTH_SCALE + POWER_OLD*(1-SMOOTH_SCALE); //SMOOTH POWER BETWEEN OLD AND NEW VALUE
  Serial.print(POWER); 
  SPACER();
  return POWER;
  
}

void SPACER(){ //USED TO CONVENIENTLY SEPERATE PRINTED VALUES DURING TROUBLESHOOTING 
  Serial.print("  |");
}

void SHUTDOWN(){
  POWER = 0; //FORCE TO ZERO
  POWER_OLD = 0; //FORCE TO ZERO
  ST.motor(DRIVE_MOTOR,POWER); //SEND ZERO COMMAND TO MOTOR
  digitalWrite(DIRECTION_PIN,HIGH); //DEFAULT DIRECTION RELAY POSITION SET TO FORWARD (HIGH)
  Serial.print("OFF");
  SPACER();
  Serial.println(' ');
}
